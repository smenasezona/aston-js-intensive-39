/*
Ответ на 1ый вопрос:
--------------------
Метод OPTIONS используется для определения возможностей веб-сервера или поддерживаемых функций конкретного ресурса.

Вызывается клиентом, когда необходимо узнать, какие HTTP-методы поддерживает сервер или конкретный ресурс, или для выполнения предварительного запроса CORS.

Используется для определения поддерживаемых методов HTTP для конкретного ресурса, а также в контексте CORS, как часть предварительного запроса для проверки возможности выполнения кросс-доменных запросов.

В заголовке запроса можно указать, какие методы и заголовки предполагается использовать в последующих запросах.

Сервер возвращает код состояния 200 и заголовок Allow, в котором перечислены поддерживаемые методы. В случае с CORS могут возвращаться дополнительные заголовки, указывающие на допустимые методы и заголовки для кросс-доменных запросов.

--------------------

Ответ на 2ой вопрос:
--------------------
HTTP/3 использует траснспортный протокол QUIC вместо TCP. QUIC работает поверх UDP и обладает улучшенной производительностью, особенно в условиях нестабильной сети. QUIC интегрирует функции транспортного и безопасного слоев, тем самым он обеспечивает меньшую задержку при установлении соединения. 

HTTP/3 решает пробелему блокировки задач (Head-of-Line blocking), где потеря пакета в одном потоке может нарушить процесс передачи пакетов в других потоках, решает он это тем, что обрабатывает потоки независимо друг от друга. 

Также в HTTP/3 улучшено управление перегрузками, там используются более совеременные методы для работы с ними. 

В HTTP/3 реализована более быстрая передача данных благодаря тому, что QUIC работает поверх UDP. Из-за этого уменьшено кол-во раундов обмена сообщениями между клиентом и сервером. 

Также в HTTP/3 улучшена безопасность, за счет того, что в протоколе теперь используется TLS 1.3. 

QUIC улучшает механизмы обнаружения и восстановления после потерь пакетов.

--------------------

Ответ на 3й вопрос
--------------------

AbortController — это интерфейс, предоставляемый веб-API для прерывания одного или нескольких веб-запросов. Он позволяет ассоциировать один объект AbortSignal с одним или несколькими запросами, что дает возможность отменить эти запросы в любой момент. 

const controller = new AbortController();

У каждого объекта AbortController есть свойство signal, которое представляет собой AbortSignal. Этот сигнал используется для передачи запроса о прерывании операций.

const signal = controller.signal;

fetch(url, { signal }).then(response => {
  // обработка ответа
}).catch(err => {
  // обработка ошибок, включая прерывание
});

controller.abort(); // отмена запроса


Когда запрос отменяется, промис, возвращаемый из fetch(), будет отклонен с исключением AbortError.

fetch(url, { signal }).catch(err => {
  if (err.name === 'AbortError') {
    // запрос был отменен
  }

Можно добавить обработчик события abort к AbortSignal, который будет вызван, когда сигнал активируется. Это позволяет реагировать на отмену асинхронной операции в реальном времени.

signal.addEventListener('abort', () => {
	...
});

В XMLHttpRequest для прерывания запросов есть метод abort()

xhr.abort(); // Отмена запроса

Отмена HTTP-запросов в библиотеке Axios для JavaScript осуществляется с использованием механизма, называемого "cancel tokens".

const CancelToken = axios.CancelToken;
const source = CancelToken.source();

Отменить выполнение Web Worker можно, вызвав метод terminate(). Этот метод немедленно останавливает воркера и освобождает все ресурсы, связанные с ним.

worker.terminate();

Если используется WebSocket, то можно закрыть соединение методом close().

const socket = new WebSocket('url'); 
socket.close();

*/

// String
let str1 = 'Hello'

let str2 = String('Hello, world!')

let num = 123
let str3 = num.toString()

// Number
let num1 = 42

let num2 = Number(42)

let num3 = parseFloat('3.14')
let num4 = parseInt('42')

// Boolean
let bool1 = true

let bool2 = Boolean(true)

let bool3 = 1 > 0
let bool4 = !!1

// Undefined
let undefined1 = undefined

let obj = {}
let undefined2 = obj.property

let name

// Null
let null1 = null

let null2 = /abc/.exec('def')

// Symbol
let symbol1 = Symbol('sym')
let symbol2 = Symbol.for('sym')

// BigInt
let bigInt1 = 123n
let big2 = BigInt('123')

/*
ReferenceError возникает, потому что переменные с let и const находятся во временной мертвой зоне до их инициализации, делая их недоступными до объявления.
*/

const res = 'B' + 'a' + (1 - 'hello')
console.log(res) // BaNaN

const res2 = (true && 3) + 'd'
console.log(res2) // 3d

const res3 = Boolean(true && 3) + 'd'
console.log(res3) // trued
